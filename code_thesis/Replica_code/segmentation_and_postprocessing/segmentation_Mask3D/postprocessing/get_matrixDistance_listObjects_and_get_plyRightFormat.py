# environment: sceneGraphs_groundTruth_Replica (yes, the name could have been changed)

'''To retrieve the the segmentation in a scene from the Replica dataset starting from the files generated by LabelMaker.
This code creates three files:
- matrix_distances_file_LabelMaker.txt (in the filename the distance that has been used is specified)
- associations_objectIdIndex_LabelMaker.json (keys are objectIDs, values are the indexes in the distance matrix)
- list_instances_LabelMaker.txt
- colorDict_frlApartments_LabelMaker.json, directly from scannet

Also saves the point cloud with an header similar to this one:


'''

# Had to use in the terminal: export PYTHONNOUSERSITE=True # maybe no

from plyfile import PlyData, PlyElement
import numpy as np
import os
import open3d as o3d
import json
import time
import copy

from scannet200_constants import VALID_CLASS_IDS_200, CLASS_LABELS_200, SCANNET_COLOR_MAP_200 # local file
from side_code.side_code import * # local file


start_time = time.time()

#
# Variables to set
#

frl_apartment = 'frl_apartment_0'
path_folderResults = '/local/home/gmarsich/Desktop/data_Replica' # if the folder does not exist, it will be created
chosen_distance = distance_Euclidean_closest_points # be aware that with distance_Euclidean_closest_points a downsampling will be performed
scaling_factor = 50 # for downsampling to perform distance_Euclidean_closest_points

# path_to_output_ply = '/local/home/gmarsich/data2TB/DATASETS/Replica/frl_apartment_0/habitat/Segmentation/mesh_semantic.ply_47.ply' # instance to visualise as a test


#
# Automatic variables, in theory they are ok like this
#

path_mask3d_folder = os.path.join(path_folderResults, frl_apartment, 'scannet200_mask3d_1')

path_save_files = os.path.join(path_folderResults, frl_apartment)
path_pred_mask = os.path.join(path_mask3d_folder, 'pred_mask')
path_predictions = os.path.join(path_mask3d_folder, 'predictions.txt')
path_mesh = os.path.join(path_mask3d_folder, 'mesh_labelled.ply')

path_save_colorDict = os.path.join(path_folderResults, 'colorDict_frlApartments_LabelMaker.json')

current_dir = os.path.dirname(os.path.abspath(__file__))
scannet_file = os.path.join(current_dir, 'scannet200_constants.py')



#
# Create dict_info, where keys are IDscene and the values are lists like [IDscannet, pcd, (sampled_pcd,) label]. Save colorDict_frlApartments_LabelMaker.json 
#

# TODO: to revise the part of building dict_info

dict_info = {}

with open(path_predictions, 'r') as file:
    for line in file:
        parts = line.strip().split()
        
        filename = parts[0]  # this contains the path
        IDscene = int(os.path.splitext(os.path.basename(filename))[0])  # extract IDscene from filename
        IDscannet = int(parts[1])  # the integer that follows the filename

        dict_info[IDscene] = [IDscannet]


dict_paths_predMask = {int(os.path.splitext(file)[0]): os.path.join(path_pred_mask, file) 
                       for file in sorted(os.listdir(path_pred_mask)) 
                       if os.path.isfile(os.path.join(path_pred_mask, file))}


mesh = o3d.io.read_point_cloud(path_mesh)
points = np.asarray(mesh.points)
colors = np.asarray(mesh.colors)

for key, value in dict_paths_predMask.items():
    selected_points = []
    with open(value, 'r') as mask_file:
        mask_lines = mask_file.readlines()

    if len(mask_lines) != len(points):
        print(f"Warning: Mask has {len(mask_lines)} lines but mesh has {len(points)} points. Skipping this mask.")
    else:
        mask = np.array([int(line.strip()) for line in mask_lines])

        selected_points = points[mask == 1]
        selected_colors = colors[mask == 1] # OBS.: it seems that one may have some points with a color different from the color associated to the instance

    pcd = o3d.geometry.PointCloud()
    pcd.points = o3d.utility.Vector3dVector(selected_points)
    pcd.colors = o3d.utility.Vector3dVector(selected_colors)

    dict_info[key].append(pcd)

    if chosen_distance != 'distance_Euclidean_centroids':
        sampled_pcd = copy.deepcopy(pcd)
        if len(pcd.points) > scaling_factor*10: # 10 has been chosen empirically, randomly
            num_points = round(len(pcd.points) / scaling_factor)
            sampled_pcd = farthest_point_sampling(pcd, num_points)

        dict_info[key].append(sampled_pcd)


valid_class_ids = VALID_CLASS_IDS_200
class_labels = CLASS_LABELS_200

dict_scannet = dict(zip(valid_class_ids, class_labels))

for key, value in dict_info.items():
    dict_info[key].append(dict_scannet[value[0]])


dict_colorMap_IDs = SCANNET_COLOR_MAP_200

dict_colorMap = {}

for key, value in dict_colorMap_IDs.items():
    dict_colorMap[dict_scannet[key]] = list(dict_colorMap_IDs[key])


with open(path_save_colorDict, 'w') as json_file:
    json.dump(dict_colorMap, json_file, indent=4)


# o3d.visualization.draw_geometries([dict_info[34][1]])
# print(dict_info[34][2])

# o3d.visualization.draw_geometries([dict_info[8][1]])
# print(dict_info[8][2])

# o3d.visualization.draw_geometries([dict_info[9][1]])
# print(dict_info[9][2])



#
# Compute and save the files that are required
#
    
matrix = compute_distance_matrix(dict_info, path_save_files, compute_distance = chosen_distance)






# end_time = time.time()
# elapsed_time = end_time - start_time
# print(f"Elapsed time: {elapsed_time:.6f} seconds")
